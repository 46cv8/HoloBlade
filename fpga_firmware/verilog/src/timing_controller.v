// File: timing_controller.v
// Generated by MyHDL 0.11
// Date: Fri Feb 26 03:22:43 2021


`timescale 1ns/10ps

module timing_controller (
    fpga_clk,
    ftdi_clk,
    reset_all,
    reset_per_frame,
    buffer_switch_done,
    dc32_fifo_full,
    dc32_fifo_almost_empty,
    dc32_fifo_read_enable,
    dc32_fifo_data_out,
    sc32_fifo_write_enable,
    sc32_fifo_read_enable,
    sc32_fifo_data_in,
    line_of_data_available,
    get_next_word,
    update,
    invert
);
// Ports
// I/O pins:
// --------
// Control:
// fpga_clk                       : Clock to drive this module
// ftdi_clk                       : Clock for FT601 32-bit FIFOs, need as dc32_fifo_full is crossing clock domains
// reset_all                      : Output reset line for all other modules
// reset_per_frame                : Output line to reset relevant components ready for a new frame
// buffer_switch_done             : Line which goes high for 1-cycle to tell modules that a buffer switch has just completed, this timing drives several modules - usb3_if and bluejay_data
// DC32-FIFO Side
// dc32_fifo_full                 : Line out of the FIFO which shall go high when the FIFO is full (32 words)
// dc32_fifo_almost_empty         : Line which is high when the FIFO has 8 or less words in it, use this as a flag to drive logic for clocking the first 8 words of a line
// dc32_fifo_read_enable          : Line to get data out of the dc32 fifo
// dc32_fifo_data_out             : 32-bit Data out of the dc32 fifo
// SC32-FIFO Side
// sc32_fifo_write_enable         : Line to write data int of the dc32 fifo
// sc32_fifo_read_enable          : Line to read data out of the dc32 fifo
// sc32_fifo_data_in              : 32-bit Data into the dc32 fifo
// Bluejay Data Interface:
// line_of_data_available         : Flag to indicate to the bluejay FSM that there is at least a line of data available in the FIFO currently (ie: more than 40 words)
// get_next_word                  : Line to instruct the TimingController that it should be clocking out data from the FIFOs
// update                         : Used to assert when a Buffer Switch shall take place
// invert                         : Used to enable DC_Balancing

input fpga_clk;
input ftdi_clk;
output reset_all;
reg reset_all;
output reset_per_frame;
reg reset_per_frame;
output buffer_switch_done;
reg buffer_switch_done;
input dc32_fifo_full;
input dc32_fifo_almost_empty;
output dc32_fifo_read_enable;
reg dc32_fifo_read_enable;
input [31:0] dc32_fifo_data_out;
output sc32_fifo_write_enable;
reg sc32_fifo_write_enable;
output sc32_fifo_read_enable;
reg sc32_fifo_read_enable;
output [31:0] sc32_fifo_data_in;
wire [31:0] sc32_fifo_data_in;
output line_of_data_available;
reg line_of_data_available;
input get_next_word;
output update;
reg update;
output invert;
reg invert;

reg [2:0] fifo_state;
reg [3:0] state;
reg [5:0] fifo_state_timeout_counter;
reg [31:0] state_timeout_counter;




assign sc32_fifo_data_in = dc32_fifo_data_out;


always @(posedge fpga_clk) begin: TIMING_CONTROLLER_RUN_FIFO_MANAGEMENT
    dc32_fifo_read_enable <= 1'b0;
    sc32_fifo_write_enable <= 1'b0;
    sc32_fifo_read_enable <= 1'b0;
    line_of_data_available <= 1'b0;
    case (fifo_state)
        3'b000: begin
            if ((state != 4'b0000)) begin
                if ((dc32_fifo_almost_empty == 1'b0)) begin
                    fifo_state <= 3'b001;
                    dc32_fifo_read_enable <= 1'b1;
                    fifo_state_timeout_counter <= 8;
                end
            end
        end
        3'b001: begin
            dc32_fifo_read_enable <= 1'b1;
            sc32_fifo_write_enable <= 1'b1;
            fifo_state_timeout_counter <= (fifo_state_timeout_counter - 1);
            if ((fifo_state_timeout_counter == 1)) begin
                fifo_state <= 3'b010;
                dc32_fifo_read_enable <= 1'b0;
                sc32_fifo_write_enable <= 1'b1;
            end
        end
        3'b010: begin
            if ((dc32_fifo_full == 1'b1)) begin
                line_of_data_available <= 1'b1;
                fifo_state <= 3'b011;
            end
        end
        3'b011: begin
            line_of_data_available <= 1'b1;
            if ((get_next_word == 1'b1)) begin
                fifo_state <= 3'b100;
                sc32_fifo_read_enable <= 1'b1;
                dc32_fifo_read_enable <= 1'b1;
                sc32_fifo_write_enable <= 1'b1;
                fifo_state_timeout_counter <= 32;
            end
        end
        3'b100: begin
            dc32_fifo_read_enable <= 1'b1;
            sc32_fifo_write_enable <= 1'b1;
            sc32_fifo_read_enable <= 1'b1;
            fifo_state_timeout_counter <= (fifo_state_timeout_counter - 1);
            if ((fifo_state_timeout_counter == 1)) begin
                fifo_state <= 3'b101;
                dc32_fifo_read_enable <= 1'b0;
                sc32_fifo_write_enable <= 1'b0;
                fifo_state_timeout_counter <= 8;
            end
        end
        3'b101: begin
            sc32_fifo_read_enable <= 1'b1;
            fifo_state_timeout_counter <= (fifo_state_timeout_counter - 1);
            if ((fifo_state_timeout_counter == 1)) begin
                fifo_state <= 3'b000;
                sc32_fifo_read_enable <= 1'b0;
            end
        end
    endcase
end


always @(posedge fpga_clk) begin: TIMING_CONTROLLER_RUN_TIMING
    reset_all <= 1'b0;
    reset_per_frame <= 1'b0;
    buffer_switch_done <= 1'b0;
    update <= 1'b0;
    invert <= 1'b0;
    case (state)
        4'b0000: begin
            state <= 4'b0001;
            state_timeout_counter <= 5;
        end
        4'b0001: begin
            reset_all <= 1'b1;
            state_timeout_counter <= (state_timeout_counter - 1);
            if ((state_timeout_counter == 1)) begin
                state_timeout_counter <= 624927;
                state <= 4'b0011;
            end
        end
        4'b0010: begin
            state_timeout_counter <= (state_timeout_counter - 1);
            if ((state_timeout_counter == 1)) begin
                state_timeout_counter <= 24;
                state <= 4'b0110;
            end
        end
        4'b0011: begin
            state_timeout_counter <= (state_timeout_counter - 1);
            if ((state_timeout_counter == 1)) begin
                state_timeout_counter <= 48;
                state <= 4'b0100;
                reset_per_frame <= 1'b1;
            end
        end
        4'b0100: begin
            update <= 1'b1;
            state_timeout_counter <= (state_timeout_counter - 1);
            if ((state_timeout_counter == 1)) begin
                state_timeout_counter <= 1;
                state <= 4'b0101;
            end
        end
        4'b0101: begin
            buffer_switch_done <= 1'b1;
            state_timeout_counter <= (state_timeout_counter - 1);
            if ((state_timeout_counter == 1)) begin
                state_timeout_counter <= 624928;
                state <= 4'b0010;
            end
        end
        4'b0110: begin
            invert <= 1'b1;
            state_timeout_counter <= (state_timeout_counter - 1);
            if ((state_timeout_counter == 1)) begin
                state_timeout_counter <= 48;
                state <= 4'b0111;
            end
        end
        4'b0111: begin
            invert <= 1'b1;
            update <= 1'b1;
            state_timeout_counter <= (state_timeout_counter - 1);
            if ((state_timeout_counter == 1)) begin
                state_timeout_counter <= 24;
                state <= 4'b1000;
            end
        end
        4'b1000: begin
            invert <= 1'b1;
            state_timeout_counter <= (state_timeout_counter - 1);
            if ((state_timeout_counter == 1)) begin
                state_timeout_counter <= 624927;
                state <= 4'b0011;
            end
        end
    endcase
end

endmodule
