
/*******************************************************************************
    Verilog netlist generated by IPGEN Radiant Software (64-bit) 1.1.0.165.1
    Soft IP Version: 1.0.0
    Fri Oct 11 16:21:55 2019
*******************************************************************************/
/*******************************************************************************
    Wrapper Module generated per user settings.
*******************************************************************************/
module FIFO_Quad_Word (clk_i, rst_i, wr_en_i, rd_en_i, wr_data_i, full_o, empty_o, rd_data_o) ;
    input clk_i ; 
    input rst_i ; 
    input wr_en_i ; 
    input rd_en_i ; 
    input [31:0] wr_data_i ; 
    output full_o ; 
    output empty_o ; 
    output [31:0] rd_data_o ; 
    FIFO_Quad_Word_ipgen_lscc_fifo #(.FAMILY("behavioral"),.ADDRESS_DEPTH(4),.DATA_WIDTH(32),.ADDRESS_WIDTH(2),.REGMODE("reg"),.RESET_MODE("sync"),.ENABLE_ALMOST_FULL_FLAG("FALSE"),.ALMOST_FULL_ASSERTION("static-dual"),.ALMOST_FULL_ASSERT_LVL(3),.ALMOST_FULL_DEASSERT_LVL(2),.ENABLE_ALMOST_EMPTY_FLAG("FALSE"),.ALMOST_EMPTY_ASSERTION("static-dual"),.ALMOST_EMPTY_ASSERT_LVL(1),.ALMOST_EMPTY_DEASSERT_LVL(2),.ENABLE_DATA_COUNT("FALSE"),
            .IMPLEMENTATION("LUT")) lscc_fifo_inst (.clk_i(clk_i), .rst_i(rst_i), .wr_en_i(wr_en_i), .rd_en_i(rd_en_i), .wr_data_i(wr_data_i[31:0]), .almost_full_th_i(2'b11), .almost_full_clr_th_i(2'b11), .almost_empty_th_i(2'b11), .almost_empty_clr_th_i(2'b11), .full_o(full_o), .empty_o(empty_o), .almost_full_o(), .almost_empty_o(), .data_cnt_o(), .rd_data_o(rd_data_o[31:0])) ; 
endmodule



module FIFO_Quad_Word_ipgen_lscc_fifo #(parameter IMPLEMENTATION = "EBR", parameter ADDRESS_DEPTH = 512, parameter ADDRESS_WIDTH = clog2(ADDRESS_DEPTH), parameter DATA_WIDTH = 18, parameter REGMODE = "reg", parameter RESET_MODE = "async", parameter ENABLE_ALMOST_FULL_FLAG = "TRUE", parameter ENABLE_ALMOST_EMPTY_FLAG = "TRUE", parameter ALMOST_FULL_ASSERTION = "static-dual", parameter ALMOST_FULL_ASSERT_LVL = 1023, parameter ALMOST_FULL_DEASSERT_LVL = 1020, parameter ALMOST_EMPTY_ASSERTION = "static-dual", parameter ALMOST_EMPTY_ASSERT_LVL = 1, parameter ALMOST_EMPTY_DEASSERT_LVL = 4, parameter ENABLE_DATA_COUNT = "FALSE", 
        parameter FAMILY = "common") (
    //--begin_param--
    //----------------------------
    // Parameters
    //----
    //--end_param--
    //--begin_ports--
    //----------------------------
    // Inputs
    //----------------------------
    input clk_i, 
    input [(DATA_WIDTH - 1):0] wr_data_i, 
    input wr_en_i, 
    input rd_en_i, 
    input rst_i, 
    input [(ADDRESS_WIDTH - 1):0] almost_full_th_i, 
    input [(ADDRESS_WIDTH - 1):0] almost_full_clr_th_i, 
    input [(ADDRESS_WIDTH - 1):0] almost_empty_th_i, 
    input [(ADDRESS_WIDTH - 1):0] almost_empty_clr_th_i, 
    //----------------------------
    // Outputs
    //----------------------------
    output [(DATA_WIDTH - 1):0] rd_data_o, 
    output full_o, 
    output empty_o, 
    output almost_full_o, 
    output almost_empty_o, 
    output [ADDRESS_WIDTH:0] data_cnt_o) ;
    //--end_ports--
    generate
        //----------------------------
        // Wire and Registers
        //----------------------------
        reg full_r = 1'b0 ; 
        reg empty_r = 1'b1 ; 
        wire wr_fifo_en_w = (wr_en_i & (~full_r)) ; 
        wire rd_fifo_en_w = (rd_en_i & (~empty_r)) ; 
        reg rd_fifo_en_prev_r = 1'b0 ; 
        wire rd_fifo_en_t_w = (rd_fifo_en_w | rd_fifo_en_prev_r) ; 
        reg [ADDRESS_WIDTH:0] wr_addr_r = {(ADDRESS_WIDTH + 1){1'b0}} ; 
        wire [(ADDRESS_WIDTH - 1):0] wr_mem_addr_w = wr_addr_r[(ADDRESS_WIDTH - 1):0] ; 
        wire [ADDRESS_WIDTH:0] wr_addr_p1_w = (wr_addr_r + 1'b1) ; 
        wire [(ADDRESS_WIDTH - 1):0] wr_mem_addr_p1_w = wr_addr_p1_w[(ADDRESS_WIDTH - 1):0] ; 
        reg [ADDRESS_WIDTH:0] rd_addr_r = {(ADDRESS_WIDTH + 1){1'b0}} ; 
        wire [(ADDRESS_WIDTH - 1):0] rd_mem_addr_w = rd_addr_r[(ADDRESS_WIDTH - 1):0] ; 
        wire [ADDRESS_WIDTH:0] rd_addr_p1_w = (rd_addr_r + 1'b1) ; 
        wire [(ADDRESS_WIDTH - 1):0] rd_mem_addr_p1_w = rd_addr_p1_w[(ADDRESS_WIDTH - 1):0] ; 
        wire [ADDRESS_WIDTH:0] diff0_w = (wr_addr_r - rd_addr_r) ; 
        wire [ADDRESS_WIDTH:0] diff1_w = ({1'b1,wr_mem_addr_w} - {1'b0,rd_mem_addr_w}) ; 
        wire [ADDRESS_WIDTH:0] diff0wren_w = (wr_addr_p1_w - rd_addr_r) ; 
        wire [ADDRESS_WIDTH:0] diff1wren_w = ({1'b1,wr_mem_addr_p1_w} - {1'b0,rd_mem_addr_w}) ; 
        wire [ADDRESS_WIDTH:0] diff0rden_w = (wr_addr_r - rd_addr_p1_w) ; 
        wire [ADDRESS_WIDTH:0] diff1rden_w = ({1'b1,wr_mem_addr_w} - {1'b0,rd_mem_addr_p1_w}) ; 
        wire diff_chk_w = ((wr_addr_r >= rd_addr_r) ? 1'b1 : 1'b0) ; 
        wire diff_chk_wren_w = ((wr_addr_p1_w >= rd_addr_r) ? 1'b1 : 1'b0) ; 
        wire diff_chk_rden_w = ((wr_addr_r >= rd_addr_p1_w) ? 1'b1 : 1'b0) ; 
        wire [ADDRESS_WIDTH:0] diff0_aeflg_w = ((wr_en_i == rd_en_i) ? diff0_w : ((wr_en_i == 1'b1) ? diff0wren_w : diff0rden_w)) ; 
        wire [ADDRESS_WIDTH:0] diff1_aeflg_w = ((wr_en_i == rd_en_i) ? diff1_w : ((wr_en_i == 1'b1) ? diff1wren_w : diff1rden_w)) ; 
        wire diff_chk_aeflg_w = ((wr_en_i == rd_en_i) ? diff_chk_w : ((wr_en_i == 1'b1) ? diff_chk_wren_w : diff_chk_rden_w)) ; 
        // -- Top-Level Assignments --
        assign full_o = full_r ; 
        assign empty_o = empty_r ; 
        //----------------------------
        // Behavioral Model
        //----------------------------
        // ---------------------
        // -- FIFO CONTROLLER --
        // ---------------------
        reg [ADDRESS_WIDTH:0] wr_addr_nxt_r = {(ADDRESS_WIDTH + 1){1'b0}} ; 
        reg [ADDRESS_WIDTH:0] rd_addr_nxt_r = {(ADDRESS_WIDTH + 1){1'b0}} ; 
        reg full_nxt_r ; 
        reg empty_nxt_r ; 
        always
            @(*)
            begin
                wr_addr_nxt_r = wr_addr_r ;
                full_nxt_r = full_r ;
                if (((wr_en_i == 1'b1) && (full_r == 1'b0))) 
                    begin
                        if ((wr_mem_addr_p1_w == rd_mem_addr_w)) 
                            begin
                                if ((wr_addr_p1_w != rd_addr_r)) 
                                    begin
                                        full_nxt_r = 1'b1 ;
                                    end
                            end
                        wr_addr_nxt_r = wr_addr_p1_w ;
                    end
                else
                    if (((wr_mem_addr_w != rd_mem_addr_w) || rd_en_i)) 
                        begin
                            full_nxt_r = 1'b0 ;
                        end
            end
        always
            @(*)
            begin
                rd_addr_nxt_r = rd_addr_r ;
                empty_nxt_r = empty_r ;
                if (((rd_en_i == 1'b1) && (empty_r == 1'b0))) 
                    begin
                        if ((rd_mem_addr_p1_w == wr_mem_addr_w)) 
                            begin
                                if ((rd_addr_p1_w == wr_addr_r)) 
                                    begin
                                        empty_nxt_r = 1'b1 ;
                                    end
                            end
                        rd_addr_nxt_r = rd_addr_p1_w ;
                    end
                else
                    if (((wr_mem_addr_w != rd_mem_addr_w) || wr_en_i)) 
                        begin
                            empty_nxt_r = 1'b0 ;
                        end
            end
        if ((RESET_MODE == "sync")) 
            begin : sync_controller
                always
                    @(posedge clk_i)
                    begin
                        if ((rst_i == 1'b1)) 
                            begin
                                wr_addr_r <=  {(ADDRESS_WIDTH + 1){1'b0}} ;
                                rd_addr_r <=  {(ADDRESS_WIDTH + 1){1'b0}} ;
                                full_r <=  1'b0 ;
                                empty_r <=  1'b1 ;
                            end
                        else
                            begin
                                wr_addr_r <=  wr_addr_nxt_r ;
                                rd_addr_r <=  rd_addr_nxt_r ;
                                full_r <=  full_nxt_r ;
                                empty_r <=  empty_nxt_r ;
                            end
                    end
            end
        else
            begin : async_controller
                always
                    @(posedge clk_i or posedge rst_i)
                    begin
                        if ((rst_i == 1'b1)) 
                            begin
                                wr_addr_r <=  {(ADDRESS_WIDTH + 1){1'b0}} ;
                                rd_addr_r <=  {(ADDRESS_WIDTH + 1){1'b0}} ;
                                full_r <=  1'b0 ;
                                empty_r <=  1'b1 ;
                            end
                        else
                            begin
                                wr_addr_r <=  wr_addr_nxt_r ;
                                rd_addr_r <=  rd_addr_nxt_r ;
                                full_r <=  full_nxt_r ;
                                empty_r <=  empty_nxt_r ;
                            end
                    end
            end
        // -- Almost Full/Empty Flag Controller --   
        if (((ENABLE_ALMOST_FULL_FLAG == "TRUE") || (ENABLE_ALMOST_EMPTY_FLAG == "TRUE"))) 
            begin : almost_empty_full_flag
                wire [(ADDRESS_WIDTH - 1):0] almost_full_tick_w = (((ALMOST_FULL_ASSERTION == "static-single") || (ALMOST_FULL_ASSERTION == "static-dual")) ? ALMOST_FULL_ASSERT_LVL : almost_full_th_i) ; 
                wire [(ADDRESS_WIDTH - 1):0] almost_full_tock_w = ((ALMOST_FULL_ASSERTION == "static-single") ? ALMOST_FULL_ASSERT_LVL : ((ALMOST_FULL_ASSERTION == "static-dual") ? ALMOST_FULL_DEASSERT_LVL : ((ALMOST_FULL_ASSERTION == "dynamic-single") ? almost_full_th_i : almost_full_clr_th_i))) ; 
                wire [(ADDRESS_WIDTH - 1):0] almost_empty_tick_w = (((ALMOST_EMPTY_ASSERTION == "static-single") || (ALMOST_EMPTY_ASSERTION == "static-dual")) ? ALMOST_EMPTY_ASSERT_LVL : almost_empty_th_i) ; 
                wire [(ADDRESS_WIDTH - 1):0] almost_empty_tock_w = ((ALMOST_EMPTY_ASSERTION == "static-single") ? ALMOST_EMPTY_ASSERT_LVL : ((ALMOST_EMPTY_ASSERTION == "static-dual") ? ALMOST_EMPTY_DEASSERT_LVL : ((ALMOST_EMPTY_ASSERTION == "dynamic-single") ? almost_empty_th_i : almost_empty_clr_th_i))) ; 
                reg almost_full_flag_r = 1'b0 ; 
                reg almost_empty_flag_r = 1'b1 ; 
                assign almost_full_o = ((ENABLE_ALMOST_FULL_FLAG == "TRUE") ? ((almost_full_flag_r | full_r) & (~empty_r)) : 1'b0) ; 
                assign almost_empty_o = ((ENABLE_ALMOST_EMPTY_FLAG == "TRUE") ? ((almost_empty_flag_r | empty_r) & (~full_r)) : 1'b0) ; 
                reg almost_full_flag_nxt_r = 1'b0 ; 
                reg almost_empty_flag_nxt_r = 1'b0 ; 
                always
                    @(*)
                    begin
                        almost_full_flag_nxt_r = almost_full_flag_r ;
                        if (diff_chk_aeflg_w) 
                            begin
                                if ((diff0_aeflg_w >= almost_full_tick_w)) 
                                    begin
                                        almost_full_flag_nxt_r = 1'b1 ;
                                    end
                                else
                                    if ((diff0_aeflg_w <= almost_full_tock_w)) 
                                        begin
                                            almost_full_flag_nxt_r = 1'b0 ;
                                        end
                            end
                        else
                            begin
                                if ((diff1_aeflg_w >= almost_full_tick_w)) 
                                    begin
                                        almost_full_flag_nxt_r = 1'b1 ;
                                    end
                                else
                                    if ((diff1_aeflg_w <= almost_full_tock_w)) 
                                        begin
                                            almost_full_flag_nxt_r = 1'b0 ;
                                        end
                            end
                    end
                always
                    @(*)
                    begin
                        almost_empty_flag_nxt_r = almost_empty_flag_r ;
                        if (diff_chk_aeflg_w) 
                            begin
                                if ((diff0_aeflg_w >= almost_empty_tock_w)) 
                                    begin
                                        almost_empty_flag_nxt_r = 1'b0 ;
                                    end
                                else
                                    if ((diff0_aeflg_w <= almost_empty_tick_w)) 
                                        begin
                                            almost_empty_flag_nxt_r = 1'b1 ;
                                        end
                            end
                        else
                            begin
                                if ((diff1_aeflg_w >= almost_empty_tock_w)) 
                                    begin
                                        almost_empty_flag_nxt_r = 1'b0 ;
                                    end
                                else
                                    if ((diff1_aeflg_w <= almost_empty_tick_w)) 
                                        begin
                                            almost_empty_flag_nxt_r = 1'b1 ;
                                        end
                            end
                    end
                if ((RESET_MODE == "sync")) 
                    begin : sync
                        always
                            @(posedge clk_i)
                            begin
                                if ((rst_i == 1'b1)) 
                                    begin
                                        almost_empty_flag_r <=  1'b1 ;
                                        almost_full_flag_r <=  1'b0 ;
                                    end
                                else
                                    begin
                                        almost_empty_flag_r <=  almost_empty_flag_nxt_r ;
                                        almost_full_flag_r <=  almost_full_flag_nxt_r ;
                                    end
                            end
                    end
                else
                    begin : async
                        always
                            @(posedge clk_i or posedge rst_i)
                            begin
                                if ((rst_i == 1'b1)) 
                                    begin
                                        almost_empty_flag_r <=  1'b1 ;
                                        almost_full_flag_r <=  1'b0 ;
                                    end
                                else
                                    begin
                                        almost_empty_flag_r <=  almost_empty_flag_nxt_r ;
                                        almost_full_flag_r <=  almost_full_flag_nxt_r ;
                                    end
                            end
                    end
            end
        // -- Enable Data Count Controller --
        if ((ENABLE_DATA_COUNT == "TRUE")) 
            begin : en_data_count
                reg [ADDRESS_WIDTH:0] data_cnt_r = {(ADDRESS_WIDTH + 1){1'b0}} ; 
                reg [ADDRESS_WIDTH:0] data_cnt_nxt_r = {(ADDRESS_WIDTH + 1){1'b0}} ; 
                assign data_cnt_o = data_cnt_r ; 
                always
                    @(*)
                    begin
                        if (empty_r) 
                            begin
                                data_cnt_nxt_r = {(ADDRESS_WIDTH + 1){1'b0}} ;
                            end
                        else
                            if (full_r) 
                                begin
                                    data_cnt_nxt_r = {1'b1,{ADDRESS_WIDTH{1'b0}}} ;
                                end
                            else
                                begin
                                    data_cnt_nxt_r = (diff_chk_aeflg_w ? diff0_aeflg_w : diff1_aeflg_w) ;
                                end
                    end
                if ((RESET_MODE == "sync")) 
                    begin : sync
                        always
                            @(posedge clk_i)
                            begin
                                if ((rst_i == 1'b1)) 
                                    begin
                                        data_cnt_r <=  {(ADDRESS_WIDTH + 1){1'b0}} ;
                                    end
                                else
                                    begin
                                        data_cnt_r <=  data_cnt_nxt_r ;
                                    end
                            end
                    end
                else
                    begin : async
                        always
                            @(posedge clk_i or posedge rst_i)
                            begin
                                if ((rst_i == 1'b1)) 
                                    begin
                                        data_cnt_r <=  {(ADDRESS_WIDTH + 1){1'b0}} ;
                                    end
                                else
                                    begin
                                        data_cnt_r <=  data_cnt_nxt_r ;
                                    end
                            end
                    end
            end
        else
            begin : genblk3
                assign data_cnt_o = {(ADDRESS_WIDTH + 1){1'b0}} ; 
            end
        if ((REGMODE == "reg")) 
            begin : genblk4
                if ((RESET_MODE == "sync")) 
                    begin : genblk1
                        always
                            @(posedge clk_i)
                            begin
                                if ((rst_i == 1'b1)) 
                                    begin
                                        rd_fifo_en_prev_r <=  1'b0 ;
                                    end
                                else
                                    begin
                                        rd_fifo_en_prev_r <=  rd_fifo_en_w ;
                                    end
                            end
                    end
                else
                    begin : genblk1
                        always
                            @(posedge clk_i or posedge rst_i)
                            begin
                                if ((rst_i == 1'b1)) 
                                    begin
                                        rd_fifo_en_prev_r <=  1'b0 ;
                                    end
                                else
                                    begin
                                        rd_fifo_en_prev_r <=  rd_fifo_en_w ;
                                    end
                            end
                    end
            end
        // -----------------
        // -- FIFO MEMORY --
        // -----------------
        if ((IMPLEMENTATION == "EBR")) 
            begin : mem_EBR
                (* syn_ramstyle="rw_check" *) reg [(DATA_WIDTH - 1):0] mem [((2 ** ADDRESS_WIDTH) - 1):0] ; 
                reg [(DATA_WIDTH - 1):0] data_raw_r = {DATA_WIDTH{1'b0}} ; 
                reg [(DATA_WIDTH - 1):0] data_buff_r = {DATA_WIDTH{1'b0}} ; 
                assign rd_data_o = ((REGMODE == "reg") ? data_buff_r : data_raw_r) ; 
                always
                    @(posedge clk_i)
                    begin
                        if ((wr_fifo_en_w == 1'b1)) 
                            begin
                                mem[wr_mem_addr_w] <=  wr_data_i ;
                            end
                    end
                always
                    @(posedge clk_i)
                    begin
                        if ((rd_fifo_en_w == 1'b1)) 
                            begin
                                data_raw_r <=  mem[rd_mem_addr_w] ;
                            end
                    end
                if ((REGMODE == "reg")) 
                    begin : mem_reg
                        if ((RESET_MODE == "sync")) 
                            begin : sync
                                always
                                    @(posedge clk_i)
                                    begin
                                        if ((rst_i == 1'b1)) 
                                            begin
                                                data_buff_r <=  {DATA_WIDTH{1'b0}} ;
                                            end
                                        else
                                            begin
                                                if ((rd_fifo_en_t_w == 1'b1)) 
                                                    begin
                                                        data_buff_r <=  data_raw_r ;
                                                    end
                                            end
                                    end
                            end
                        else
                            begin : async
                                always
                                    @(posedge clk_i or posedge rst_i)
                                    begin
                                        if ((rst_i == 1'b1)) 
                                            begin
                                                data_buff_r <=  {DATA_WIDTH{1'b0}} ;
                                            end
                                        else
                                            begin
                                                if ((rd_fifo_en_t_w == 1'b1)) 
                                                    begin
                                                        data_buff_r <=  data_raw_r ;
                                                    end
                                            end
                                    end
                            end
                    end
            end
        else
            begin : mem_LUT
                (* syn_ramstyle="registers" *) reg [(DATA_WIDTH - 1):0] mem [((2 ** ADDRESS_WIDTH) - 1):0] ; 
                reg [(DATA_WIDTH - 1):0] data_raw_r = {DATA_WIDTH{1'b0}} ; 
                reg [(DATA_WIDTH - 1):0] data_buff_r = {DATA_WIDTH{1'b0}} ; 
                assign rd_data_o = ((REGMODE == "reg") ? data_buff_r : data_raw_r) ; 
                always
                    @(posedge clk_i)
                    begin
                        if ((wr_fifo_en_w == 1'b1)) 
                            begin
                                mem[wr_mem_addr_w] <=  wr_data_i ;
                            end
                    end
                always
                    @(posedge clk_i)
                    begin
                        if ((rd_fifo_en_w == 1'b1)) 
                            begin
                                data_raw_r <=  mem[rd_mem_addr_w] ;
                            end
                    end
                if ((REGMODE == "reg")) 
                    begin : mem_reg
                        if ((RESET_MODE == "sync")) 
                            begin : sync
                                always
                                    @(posedge clk_i)
                                    begin
                                        if ((rst_i == 1'b1)) 
                                            begin
                                                data_buff_r <=  {DATA_WIDTH{1'b0}} ;
                                            end
                                        else
                                            begin
                                                if ((rd_fifo_en_t_w == 1'b1)) 
                                                    begin
                                                        data_buff_r <=  data_raw_r ;
                                                    end
                                            end
                                    end
                            end
                        else
                            begin : async
                                always
                                    @(posedge clk_i or posedge rst_i)
                                    begin
                                        if ((rst_i == 1'b1)) 
                                            begin
                                                data_buff_r <=  {DATA_WIDTH{1'b0}} ;
                                            end
                                        else
                                            begin
                                                if ((rd_fifo_en_t_w == 1'b1)) 
                                                    begin
                                                        data_buff_r <=  data_raw_r ;
                                                    end
                                            end
                                    end
                            end
                    end
            end
    endgenerate
    //------------------------------------------------------------------------------
    // Function Definition
    //------------------------------------------------------------------------------
    function [31:0] clog2 ; 
        input [31:0] value ; 
        reg [31:0] num ; 
        begin
            num = (value - 1) ;
            for (clog2 = 0 ; (num > 0) ; clog2 = (clog2 + 1))
                num = (num >> 1) ;
        end
    endfunction
endmodule


