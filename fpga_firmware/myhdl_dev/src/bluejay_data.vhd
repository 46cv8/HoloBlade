-- File: bluejay_data.vhd
-- Generated by MyHDL 0.11
-- Date: Fri Feb 28 09:43:02 2020



package pck_bluejay_data is

attribute enum_encoding: string;

type t_enum_t_state_1 is (
	IDLE,
	LINE_OUT_ENTER,
	LINE_OUT_DATA,
	LINE_OUT_BLANK,
	FRAME_END_BLANK,
	FRAME_END_UPDATE_HIGH
	);

end package pck_bluejay_data;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_011.all;

use work.pck_bluejay_data.all;

entity bluejay_data is
    port (
        clk_i: in std_logic;
        reset_i: in std_logic;
        state: inout t_enum_t_state_1;
        new_frame_i: in std_logic;
        data_i: in unsigned(31 downto 0);
        next_line_rdy_i: in std_logic;
        fifo_empty_i: in std_logic;
        get_next_word_o: out std_logic;
        data_o: out unsigned(31 downto 0);
        sync_o: out std_logic;
        valid_o: inout std_logic;
        update_o: out std_logic;
        invert_o: in std_logic
    );
end entity bluejay_data;
-- Peripheral to clock data out to a Bluejay SLM's Data Interface
-- 
-- I/O pins:
-- --------
-- Control:
-- clk_i            : 50MHz input clock
-- reset_i          : Reset line
-- state            : Current state, output for debug in simulator
-- new_frame_i      : Signal line to indicate that we want to start outputting a new frame
-- Read-Side:
-- data_i           : 32-bit input data to be shown on SLM
-- next_line_rdy_i  : line to indicate that a new line of data is available, active-high for 1 cycle
-- fifo_empty_i     : flag to indicate whether or not the FIFO is empty
-- get_next_word_o  : line to pull next data word out of fifo 
-- Write-Side:
-- data_o           : 32-bit output line to data interface on Bluejay SLM
-- sync_o           : Synchronisation line on Bluejay SLM, used to control which address we are writing to
-- valid_o          : Hold high while writing out a line
-- update_o         : Used to assert when a Buffer Switch shall take place
-- invert_o         : Used to enable DC_Balancing

architecture MyHDL of bluejay_data is



signal data_output_active_cmd: std_logic;
signal get_next_word_cmd: std_logic;
signal h_counter: unsigned(7 downto 0);
signal state_timeout_counter: unsigned(7 downto 0);
signal v_counter: unsigned(10 downto 0);

begin




BLUEJAY_DATA_UPDATE: process (clk_i) is
begin
    if rising_edge(clk_i) then
        sync_o <= '0';
        valid_o <= valid_o;
        update_o <= '0';
        case state is
            when IDLE =>
                if ((next_line_rdy_i = '1') and (v_counter >= 0)) then
                    state <= LINE_OUT_ENTER;
                    get_next_word_cmd <= '1';
                end if;
            when LINE_OUT_ENTER =>
                h_counter <= to_unsigned(40, 8);
                valid_o <= '1';
                state <= LINE_OUT_DATA;
            when LINE_OUT_DATA =>
                get_next_word_cmd <= '1';
                state <= LINE_OUT_DATA;
                h_counter <= (h_counter - 1);
                valid_o <= '1';
                if (signed(resize(h_counter, 9)) = (0 + 1)) then
                    state <= LINE_OUT_BLANK;
                    get_next_word_cmd <= '0';
                    valid_o <= '0';
                    h_counter <= to_unsigned(0, 8);
                    data_output_active_cmd <= '0';
                    state_timeout_counter <= to_unsigned(4, 8);
                end if;
            when others =>
                if (state = LINE_OUT_BLANK) then
                    state_timeout_counter <= (state_timeout_counter - 1);
                    if (state_timeout_counter = 1) then
                        state_timeout_counter <= to_unsigned(0, 8);
                        v_counter <= (v_counter - 1);
                        if (v_counter = 1) then
                            state <= FRAME_END_BLANK;
                            state_timeout_counter <= to_unsigned(12, 8);
                        else
                            state <= IDLE;
                        end if;
                    end if;
                elsif (state = FRAME_END_BLANK) then
                    state_timeout_counter <= (state_timeout_counter - 1);
                    if (signed(resize(state_timeout_counter, 9)) = (0 + 1)) then
                        state_timeout_counter <= to_unsigned(48, 8);
                        state <= FRAME_END_UPDATE_HIGH;
                    end if;
                elsif (state = FRAME_END_UPDATE_HIGH) then
                    update_o <= '1';
                    state_timeout_counter <= (state_timeout_counter - 1);
                    if (signed(resize(state_timeout_counter, 9)) = (0 + 1)) then
                        state_timeout_counter <= to_unsigned(0, 8);
                        state <= IDLE;
                    end if;
                end if;
        end case;
        if (new_frame_i = '1') then
            v_counter <= to_unsigned(2, 11);
        end if;
        if (reset_i = '1') then
            data_output_active_cmd <= '0';
            sync_o <= '0';
            valid_o <= '0';
            update_o <= '0';
            h_counter <= to_unsigned(0, 8);
            v_counter <= to_unsigned(0, 11);
            state <= IDLE;
        end if;
    end if;
end process BLUEJAY_DATA_UPDATE;

BLUEJAY_DATA_CHECK_FIFO_NOT_EMPTY: process (fifo_empty_i, get_next_word_cmd) is
begin
    if ((get_next_word_cmd = '1') and (fifo_empty_i = '0')) then
        get_next_word_o <= '1';
    else
        get_next_word_o <= '0';
    end if;
end process BLUEJAY_DATA_CHECK_FIFO_NOT_EMPTY;

BLUEJAY_DATA_OUTPUT_CONNECT: process (data_output_active_cmd, data_i) is
begin
    if bool(data_output_active_cmd) then
        data_o <= data_i;
    else
        data_o <= to_unsigned(0, 32);
    end if;
end process BLUEJAY_DATA_OUTPUT_CONNECT;

end architecture MyHDL;
