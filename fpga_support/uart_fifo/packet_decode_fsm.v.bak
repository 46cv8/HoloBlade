// We use a State Machine to decide what to do with the data as it comes in
// This allows us to control syncing of the data to make sure we don't lose track of where we are
// At a higher level, there are three 'modes' of operation
//    - IDLE, The Decode State Machine shall be reset to this whenever it receives the RESYNC sequence "0x41,0x6F,0xDC,0x1E"
//    - PRE,  Waiting to receive the MAGIC_NUMER sequence, "0xD7,0x8C,0x1B,0x74" , straight after which we shall receive the data payload
//    - DATA, Receiving payload data which will be processed by the DataManager. All these bytes shall go straight into the FIFO
	
	
	
	
module PACKET_DECODE_FSM(
	
	// Control Signals
	input i_clk
	input i_reset
	
	// Inputs
	input[31:0] i_recv_data_word,
	
	// Outputs
   output o_start_data_payload,
	output [31:0] o_payload_data_word
//	output 
	
); 

// Magic Numbers for Reset and Resync
RESYNC    = 32h'416FDC1E;
MAGIC_NUM = 32h'D78C1B74;

localparam [1:0] // for 3 states : size_state = 1:0
    sIDLE    = 0,
    sDATA    = 1,
    sRESYNC1 = 2
    
    reg[1:0] state_reg, state_next;  


// state register : state_reg
// This process contains sequential part and all the D-FF are 
// included in this process. Hence, only 'clk' and 'reset' are 
// required for this process. 
always @(posedge i_clock, posedge reset) begin
    if (reset) begin
        state_reg <= sIDLE;
    end
    else begin
        state_reg <= state_next;
    end
end 

// next state logic : state_next
// This is combinational of the sequential design, 
// which contains the logic for next-state
// include all signals and input in sensitive-list except state_next
// next state logic : state_next
// This is combinational of the sequential design, 
// which contains the logic for next-state
// include all signals and input in sensitive-list except state_next
always @(i_recv_data_word, state_reg) begin 

    state_next = state_reg; // default state_next
    case (state_reg)
        sIDLE : begin
            output1 = <value>;
            output2 = <value>;
            ...
            if ( (i_recv_data_word) && (o_payload_data_word==MAGIC_NUM) ) begin  // 
                state_next = s1; 
            end
            else if (<condition>) begin  // add all the required conditionstion
                state_next = ...; 
            end
            else begin // remain in current state
                state_next = s0; 
            end
        end
        s1 : begin
            output1 = <value>;
            output2 = <value>;
            ...
            if (<condition>) begin // if (input1 = 2'b10) then
                state_next = s2; 
            end
            else if (<condition>) begin // add all the required conditionstions
                state_next = ...; 
            end
            else begin// remain in current state
                state_next = s1; 
            end
        end
        s2 : begin
            ...
        end
    endcase
end 