// File: usb3_if.v
// Generated by MyHDL 0.11
// Date: Mon Apr  6 15:26:32 2020


`timescale 1ns/10ps

module usb3_if (
    reset,
    ftdi_clk,
    FR_RXF,
    FT_OE,
    FT_RD,
    usb3_data_in,
    fpga_clk,
    fifo_empty,
    fifo_dataline_available,
    get_next_word,
    fifo_data_out
);
// Ports
// I/O pins:
// --------
// Control:
// reset_i                 : Reset line TODO: Wire this up to something
// USB-Fifo Side:
// ftdi_clk                : 100MHz input clock from USB Chip to synchronise with reading from FT601 32-bit FIFOs
// FR_RXF                  : RXF_N tells us if data is available on the USB3 Chip and is an input
// FT_OE                   : OE_N is an active low output signal to tell the USB3 Chip that the FPGA is the bus master while asserted
// FT_RD                   : RD_N is an active low output signal to tell that USB3 Chip that data is being read (ie: it is the RD signal for the USB3 FIFO)
// usb3_data_in            : 32-bit wide Data lines from the FT601
// FPGA side:
// fpga_clk                : Main FPGA clock
// fifo_empty              : Is our fifo empty?
// fifo_dataline_available : Goes high when there are at least 40 lines of data available in the internal FIFO
// get_next_word           : Line to pull data from FIFO
// fifo_data_out           : 32-bit Data Out from internal 32-wide, 64-deep FIFO

input reset;
input ftdi_clk;
input [31:0] FR_RXF;
output FT_OE;
wire FT_OE;
output FT_RD;
wire FT_RD;
input usb3_data_in;
input fpga_clk;
input fifo_empty;
input fifo_dataline_available;
input get_next_word;
input [31:0] fifo_data_out;

wire RD_N;
reg RD_N_r;
reg OE_N_r;
wire RXF_N;
wire OE_N;




assign RXF_N = (!FR_RXF);
assign FT_OE = (!OE_N);
assign FT_RD = (!RD_N);



assign OE_N = OE_N_r;
assign RD_N = RD_N_r;


always @(posedge ftdi_clk) begin: USB3_IF_USB3_READOUT_SEQ_LOGIC
    if (((RXF_N == 1'b1) || (1'b0 == 1'b1))) begin
        OE_N_r <= 1'b1;
        RD_N_r <= 1'b1;
    end
    else if (((RXF_N == 1'b1) && (OE_N == 1'b0) && (1'b0 == 1'b1))) begin
        OE_N_r <= 1'b1;
        RD_N_r <= 1'b0;
    end
    else if (((RXF_N == 1'b1) && (OE_N == 1'b1) && (1'b0 == 1'b1))) begin
        OE_N_r <= 1'b1;
        RD_N_r <= 1'b1;
    end
end

endmodule
