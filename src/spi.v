// File: spi.v
// Generated by MyHDL 0.11
// Date: Wed May 20 02:20:11 2020


`timescale 1ns/10ps

module spi (
    i_clock,
    enable,
    i_reset,
    start_transfer,
    multi_byte_spi_trans_flag,
    busy,
    o_transaction_complete,
    MOSI,
    MISO,
    CS,
    SCLK,
    Tx_Upper_Byte,
    Tx_Lower_Byte,
    Rx_Upper_Byte,
    Rx_Lower_Byte
);
// MyHDL implementation of our SPI Module
// 
// I/O pins:
// --------
// Control:
// i_clock                    : Clock to drive this module
// enable                     : Output reset line for all other modules
// i_reset                    :
// start_transfer             :
// multi_byte_spi_trans_flag  :
// Status                     :
// busy                       :
// o_transaction_complete     : Goes high for 1 cycle when a SPI transfer is complete
// SPI Outputs:
// MOSI                       :
// MISO                       :
// CS                         :
// SCLK                       :
// Data Lines:
//     Tx_Upper_Byte              : Typically used for register address
//     Tx_Lower_Byte              : Typically used to set data to a register
//     Rx_Upper_Byte              : Not typically used
//     Rx_Lower_Byte              : Typically used to read data from a register

input i_clock;
input enable;
input i_reset;
input start_transfer;
input multi_byte_spi_trans_flag;
output busy;
reg busy;
output o_transaction_complete;
reg o_transaction_complete;
output MOSI;
wire MOSI;
input MISO;
output CS;
reg CS;
output SCLK;
reg SCLK;
input [7:0] Tx_Upper_Byte;
input [7:0] Tx_Lower_Byte;
output [7:0] Rx_Upper_Byte;
reg [7:0] Rx_Upper_Byte;
output [7:0] Rx_Lower_Byte;
reg [7:0] Rx_Lower_Byte;

reg [15:0] tx_shift_reg;
reg [3:0] state;
reg [15:0] rx_shift_reg;
wire CLEAR_ACTIVE_LOW;
wire ASSERT_ACTIVE_LOW;
wire blank_bit;
reg [9:0] counter;

assign CLEAR_ACTIVE_LOW = 1'd1;
assign ASSERT_ACTIVE_LOW = 1'd0;
assign blank_bit = 1'd0;


always @(posedge i_clock) begin: SPI_FSM_UPDATE
    if ((i_reset == 1'b1)) begin
        state <= 4'b0000;
        counter <= 0;
        tx_shift_reg <= 0;
        rx_shift_reg <= 0;
    end
    else begin
        SCLK <= 1'b0;
        CS <= CLEAR_ACTIVE_LOW;
        busy <= 1'b1;
        o_transaction_complete <= 1'b0;
        case (state)
            4'b0000: begin
                busy <= 1'b0;
                if (((enable == 1'b1) && (start_transfer == 1'b1))) begin
                    state <= 4'b0001;
                    tx_shift_reg <= {Tx_Upper_Byte, Tx_Lower_Byte};
                end
            end
            4'b0001: begin
                counter <= 400;
                state <= 4'b0010;
                CS <= ASSERT_ACTIVE_LOW;
            end
            4'b0010: begin
                CS <= ASSERT_ACTIVE_LOW;
                counter <= (counter - 1);
                if (((counter % 50) < 25)) begin
                    SCLK <= 1'b0;
                end
                else begin
                    SCLK <= 1'b1;
                end
                if (((counter % 50) == (50 - 1))) begin
                    rx_shift_reg <= {rx_shift_reg[15-1:0], MISO};
                end
                if (((counter % 50) == (25 - 1))) begin
                    tx_shift_reg <= {tx_shift_reg[15-1:0], blank_bit};
                end
                if ((counter == (0 + 1))) begin
                    counter <= 400;
                    state <= 4'b0011;
                end
            end
            4'b0011: begin
                CS <= ASSERT_ACTIVE_LOW;
                counter <= (counter - 1);
                if (((counter % 50) > 25)) begin
                    SCLK <= 1'b1;
                end
                else begin
                    SCLK <= 1'b0;
                end
                if (((counter % 50) == (50 - 1))) begin
                    rx_shift_reg <= {rx_shift_reg[15-1:0], MISO};
                end
                if (((counter % 50) == (25 - 1))) begin
                    tx_shift_reg <= {tx_shift_reg[15-1:0], blank_bit};
                end
                if ((counter == (0 + 1))) begin
                    state <= 4'b0100;
                    CS <= CLEAR_ACTIVE_LOW;
                end
            end
            4'b0100: begin
                Rx_Upper_Byte <= rx_shift_reg[16-1:8];
                Rx_Lower_Byte <= rx_shift_reg[8-1:0];
                state <= 4'b0101;
            end
            4'b0101: begin
                o_transaction_complete <= 1'b1;
                busy <= 1'b0;
                state <= 4'b0000;
            end
        endcase
    end
end



assign MOSI = tx_shift_reg[15];

endmodule
