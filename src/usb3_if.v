// File: usb3_if.v
// Generated by MyHDL 0.11
// Date: Tue Jun  9 16:41:20 2020


`timescale 1ns/10ps

module usb3_if (
    reset_per_frame,
    buffer_switch_done,
    ftdi_clk,
    FR_RXF,
    FT_OE,
    FT_RD,
    usb3_data_in,
    write_to_dc32_fifo,
    dc32_fifo_data_in,
    dc32_fifo_almost_full,
    dc32_fifo_empty
);
// Ports
// I/O pins:
// --------
// Control:
// reset_per_frame           : Reset line which allows us to reset state after each buffer switch
// buffer_switch_done        : Line to tell the object that a buffer switch has occured
// USB-Fifo Side:  
// ftdi_clk                  : 100MHz input clock from USB Chip to synchronise with reading from FT601 32-bit FIFOs
// FR_RXF                    : RXF_N tells us if data is available on the USB3 Chip and is an input
// FT_OE                     : OE_N is an active low output signal to tell the USB3 Chip that the FPGA is the bus master while asserted
// FT_RD                     : RD_N is an active low output signal to tell that USB3 Chip that data is being read (ie: it is the RD signal for the USB3 FIFO)
// usb3_data_in              : 32-bit wide Data lines from the FT601
// FIFO-side:
// write_to_dc32_fifo        : Signal to write to the interfacing FIFO
// dc32_fifo_data_in         : Data which shall go into 32-bit 
// dc32_fifo_almost_full     : Goes high when therea are 40 items in FIFO and then clears at 1
// dc32_fifo_empty           : Goes high when the FIFO is empty

input reset_per_frame;
input buffer_switch_done;
input ftdi_clk;
input FR_RXF;
output FT_OE;
reg FT_OE;
output FT_RD;
reg FT_RD;
input [31:0] usb3_data_in;
output write_to_dc32_fifo;
reg write_to_dc32_fifo;
output [31:0] dc32_fifo_data_in;
reg [31:0] dc32_fifo_data_in;
input dc32_fifo_almost_full;
input dc32_fifo_empty;

reg [2:0] state;
reg [31:0] usb3_data_in_latched;
reg [3:0] state_timeout_counter;



always @(negedge ftdi_clk) begin: USB3_IF_USB3_READOUT_LOGIC_STATE
    FT_OE <= 1'b1;
    FT_RD <= 1'b1;
    write_to_dc32_fifo <= 1'b0;
    case (state)
        3'b000: begin
            if ((buffer_switch_done == 1'b1)) begin
                state <= 3'b001;
            end
        end
        3'b001: begin
            if (((FR_RXF == 1'b0) && (dc32_fifo_almost_full == 1'b0))) begin
                state <= 3'b011;
                state_timeout_counter <= 3;
            end
        end
        3'b011: begin
            state_timeout_counter <= (state_timeout_counter - 1);
            if ((state_timeout_counter == 1)) begin
                FT_OE <= 1'b0;
                state <= 3'b100;
            end
        end
        3'b100: begin
            FT_OE <= 1'b0;
            FT_RD <= 1'b0;
            state <= 3'b101;
        end
        3'b101: begin
            write_to_dc32_fifo <= 1'b1;
            if ((dc32_fifo_almost_full == 1'b1)) begin
                state <= 3'b010;
            end
            else if ((FR_RXF == 1'b1)) begin
                state <= 3'b001;
            end
            else begin
                FT_OE <= 1'b0;
                FT_RD <= 1'b0;
            end
        end
        3'b010: begin
            if ((dc32_fifo_empty == 1'b1)) begin
                state <= 3'b001;
            end
        end
    endcase
end


always @(posedge ftdi_clk) begin: USB3_IF_LATCH_DATA_AS_SOON_AS_VALID
    usb3_data_in_latched <= usb3_data_in;
end


always @(negedge ftdi_clk) begin: USB3_IF_OUTPUT_LATCHED_DATA_FOR_FIFO
    dc32_fifo_data_in <= usb3_data_in_latched;
end


always @(reset_per_frame) begin: USB3_IF_RESET
    reg state_timeout_counter;
    reg usb3_data_in_latched;
    if ((reset_per_frame == 1'b1)) begin
        usb3_data_in_latched = 0;
        state_timeout_counter = 0;
    end
end

endmodule
