// File: usb3_if.v
// Generated by MyHDL 0.11
// Date: Wed Jun 10 20:25:25 2020


`timescale 1ns/10ps

module usb3_if (
    fpga_clk,
    reset_per_frame,
    buffer_switch_done,
    ftdi_clk,
    FR_RXF,
    FT_OE,
    FT_RD,
    usb3_data_in,
    write_to_dc32_fifo,
    dc32_fifo_data_in,
    dc32_fifo_almost_full,
    dc32_fifo_empty,
    STATE_DEBUG_B0
);
// Ports
// I/O pins:
// --------
// Control:
// fpga_clk                  : Need to feed in the main FPGA clock as reset_per_frame and buffer_switch_done are both on the main clock
// reset_per_frame           : Reset line which allows us to reset state after each buffer switch
// buffer_switch_done        : Line to tell the object that a buffer switch has occured
// USB-Fifo Side:  
// ftdi_clk                  : 100MHz input clock from USB Chip to synchronise with reading from FT601 32-bit FIFOs
// FR_RXF                    : RXF_N tells us if data is available on the USB3 Chip and is an input
// FT_OE                     : OE_N is an active low output signal to tell the USB3 Chip that the FPGA is the bus master while asserted
// FT_RD                     : RD_N is an active low output signal to tell that USB3 Chip that data is being read (ie: it is the RD signal for the USB3 FIFO)
// usb3_data_in              : 32-bit wide Data lines from the FT601
// FIFO-side:
// write_to_dc32_fifo        : Signal to write to the interfacing FIFO
// dc32_fifo_data_in         : Data which shall go into 32-bit 
// dc32_fifo_almost_full     : Goes high when therea are 40 items in FIFO and then clears at 1
// dc32_fifo_empty           : Goes high when the FIFO is empty

input fpga_clk;
input reset_per_frame;
input buffer_switch_done;
input ftdi_clk;
input FR_RXF;
output FT_OE;
reg FT_OE;
output FT_RD;
reg FT_RD;
input [31:0] usb3_data_in;
output write_to_dc32_fifo;
reg write_to_dc32_fifo;
output [31:0] dc32_fifo_data_in;
reg [31:0] dc32_fifo_data_in;
input dc32_fifo_almost_full;
input dc32_fifo_empty;
output [2:0] STATE_DEBUG_B0;
reg [2:0] STATE_DEBUG_B0;

reg reset_per_frame_latched;
reg [31:0] usb3_data_in_latched;
reg [2:0] state;
reg buffer_switch_done_latched;
reg [10:0] num_lines_clocked_out;
reg [3:0] state_timeout_counter;



always @(negedge ftdi_clk) begin: USB3_IF_USB3_READOUT_LOGIC_STATE
    FT_OE <= 1'b1;
    FT_RD <= 1'b1;
    if ((reset_per_frame_latched == 1'b1)) begin
        state <= 3'b000;
        state_timeout_counter <= 0;
    end
    else begin
        case (state)
            3'b000: begin
                if ((buffer_switch_done_latched == 1'b1)) begin
                    if ((FR_RXF == 1'b0)) begin
                        state <= 3'b001;
                        num_lines_clocked_out <= 16;
                    end
                    else begin
                        state <= 3'b000;
                    end
                end
            end
            3'b001: begin
                if ((FR_RXF == 1'b0)) begin
                    state <= 3'b011;
                end
            end
            3'b011: begin
                FT_OE <= 1'b0;
                state <= 3'b100;
            end
            3'b100: begin
                FT_OE <= 1'b0;
                FT_RD <= 1'b0;
                state <= 3'b101;
            end
            3'b101: begin
                if ((dc32_fifo_almost_full == 1'b1)) begin
                    num_lines_clocked_out <= (num_lines_clocked_out - 1);
                    state <= 3'b010;
                end
                else if ((FR_RXF == 1'b1)) begin
                    state <= 3'b001;
                end
                else begin
                    FT_OE <= 1'b0;
                    FT_RD <= 1'b0;
                end
            end
            3'b010: begin
                if ((dc32_fifo_empty == 1'b1)) begin
                    if ((num_lines_clocked_out == 0)) begin
                        state <= 3'b000;
                    end
                    else begin
                        state <= 3'b001;
                    end
                end
            end
        endcase
    end
end


always @(posedge ftdi_clk) begin: USB3_IF_LATCH_DATA_AS_SOON_AS_VALID
    if ((reset_per_frame_latched == 1'b1)) begin
        usb3_data_in_latched <= 0;
    end
    else begin
        usb3_data_in_latched <= usb3_data_in;
    end
end


always @(negedge ftdi_clk) begin: USB3_IF_OUTPUT_LATCHED_DATA_FOR_FIFO
    dc32_fifo_data_in <= usb3_data_in_latched;
end


always @(posedge fpga_clk) begin: USB3_IF_LATCH_FROM_FPGA_CLOCK
    buffer_switch_done_latched <= 1'b0;
    reset_per_frame_latched <= 1'b0;
    if ((buffer_switch_done == 1'b1)) begin
        buffer_switch_done_latched <= 1'b1;
    end
    if ((reset_per_frame == 1'b1)) begin
        reset_per_frame_latched <= 1'b1;
    end
end


always @(negedge ftdi_clk) begin: USB3_IF_FLAG_STATE_CHANGE_DEBUG
    case (state)
        3'b000: begin
            STATE_DEBUG_B0 <= 3'h1;
        end
        3'b001: begin
            STATE_DEBUG_B0 <= 3'h2;
        end
        3'b010: begin
            STATE_DEBUG_B0 <= 3'h3;
        end
        3'b011: begin
            STATE_DEBUG_B0 <= 3'h4;
        end
        3'b100: begin
            STATE_DEBUG_B0 <= 3'h5;
        end
        3'b101: begin
            STATE_DEBUG_B0 <= 3'h6;
        end
        default: begin
            STATE_DEBUG_B0 <= 3'h0;
        end
    endcase
end


always @(FT_OE, FT_RD, FR_RXF) begin: USB3_IF_WRITE_TO_DC_FIFO_LOGIC
    if (((FR_RXF == 1'b0) && (FT_OE == 1'b0) && (FT_RD == 1'b0))) begin
        write_to_dc32_fifo = 1'b1;
    end
    else begin
        write_to_dc32_fifo = 1'b0;
    end
end

endmodule
